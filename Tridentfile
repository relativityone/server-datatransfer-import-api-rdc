#!groovy

library 'SlackHelpers@5.2.0-Trident'
properties([
    [$class: 'BuildDiscarderProperty', strategy: [$class: 'LogRotator', artifactDaysToKeepStr: '7', artifactNumToKeepStr: '30', daysToKeepStr: '7', numToKeepStr: '30']],
    parameters([
        choice(defaultValue: 'DEV',choices: ["DEV", "GOLD - RDC AND SDK", "GOLD - RDC ONLY", "GOLD - SDK ONLY"], description: "Choose your build type, only gold can produce production packages.", name: 'buildType'),
        choice(defaultValue: 'Release', choices: ["Release","Debug"], description: 'Build config', name: 'buildConfig'),
        choice(defaultValue: 'normal', choices: ["quiet", "minimal", "normal", "detailed", "diagnostic"], description: 'Build verbosity', name: 'buildVerbosity'),
        string(defaultValue: '#import-api-rdc-build', description: 'Slack Channel title where to report the pipeline results', name: 'slackChannel'),
        booleanParam(defaultValue: true, description: "Enable or disable running unit tests", name: 'runUnitTests'),
        booleanParam(defaultValue: false, description: "Enable or disable running integration tests", name: 'runIntegrationTests'),
        booleanParam(defaultValue: true, description: "Enable or disable creating a code coverage report", name: 'createCodeCoverageReport'),
        choice(defaultValue: 'hyperv', choices: ["hyperv"], description: 'The test environment used for integration tests and code coverage', name: 'testEnvironment'),
        booleanParam(defaultValue: true, description: """Enable or disable publishing NuGet packages, default true, but can be blocked by type of build and branch type.
        This is only for debug purposes.""", name: 'publishPackages')
    ])
])

// Do not modify.
def knife = 'C:\\Python27\\Lib\\site-packages\\jeeves\\knife.rb'
def sessionID = System.currentTimeMillis().toString()
def eventHash = java.security.MessageDigest.getInstance("MD5").digest(env.JOB_NAME.bytes).encodeHex().toString()
def buildVersion = ""
def packageVersion = ""
def int testResultsPassed = 0
def int testResultsFailed = 0
def int testResultsSkipped = 0

// The following code is needed because we build a pull request according to Jenkins, 'so' the env.Branch does not return a valid branch name, but only 'PR-1234', and we need the branch name for our logic.
def branchName = env.BRANCH_NAME
if(branchName.startsWith('PR-'))
{
    branchName = env.CHANGE_BRANCH
}
def isReleaseBranch = branchName.startsWith('release-')
def isGoldBuild = (params.buildType != 'DEV')
def publishRdc =(!isReleaseBranch || (isReleaseBranch && params.buildType == 'GOLD - RDC AND SDK')|| (isReleaseBranch && params.buildType == 'GOLD - RDC ONLY'))
def publishSdk =(!isReleaseBranch || (isReleaseBranch && params.buildType == 'GOLD - RDC AND SDK')|| (isReleaseBranch && params.buildType == 'GOLD - SDK ONLY'))
def publishSdkAndRdc = (publishSdk && publishRdc)
build = params.build



// The code coverage report runs the integration tests + unit tests.
def shouldRuncodeCoverageReport = params.createCodeCoverageReport && params.runIntegrationTests && params.runUnitTests

// Disable running unit tests if we already run the code coverage report (that invokes the unit tests as well)
def shouldRunUnitTests = params.runUnitTests && !shouldRuncodeCoverageReport

// Disable running integration tests if we already run the code coverage report (that invokes the integration tests as well)
def shouldRunIntegrationTests = params.runIntegrationTests && !shouldRuncodeCoverageReport
						
						
timestamps
{
    timeout(time: 3, unit: 'HOURS')
    {
        node('role-build-agent||buildAgent')
        {
            try
            {
				stage ('Clean') 
				{
					deleteDir()
				}
				
                stage('Checkout')
                {
                    checkout([
                        $class: 'GitSCM',
                        branches: scm.branches,
                        doGenerateSubmoduleConfigurations: scm.doGenerateSubmoduleConfigurations,
                        extensions: [[$class: 'CloneOption', noTags: false, shallow: false, reference: '']] + [[$class: 'CleanCheckout']],
                        userRemoteConfigs: scm.userRemoteConfigs,
                     ])
                    notifyBitbucket()
                }

                try
                {
                    stage('Retrieve version')
                    { 
                        echo "Is release branch = $isReleaseBranch"
                        echo "Run integration tests = ${shouldRunIntegrationTests}"
                        echo "Is isGoldBuild = $isGoldBuild"
                        echo "Retrieving the semantic versions"
                        echo "Using new build strategy"
                        def outputString = runCommandWithOutput(".\\build.ps1 BuildVersion  -Branch '${branchName}'")
                        def outputStringParsed = extractValue("buildVersion", outputString)
                        currentBuild.displayName = "$outputStringParsed"
                        buildVersion = outputStringParsed
                    }
					
					stage('Check sdk dependencies')
					{
					    echo "checking dependencies of the .sdk .nuspec file"
						powershell ".\\build.ps1 CheckSdkDependencies"
					}


                    stage('Build binaries') 
                    {
                        echo "Building the binaries for version $buildVersion"
                        output = powershell ".\\build.ps1 UpdateAssemblyInfo,Build -Configuration '${params.buildConfig}' -Verbosity '${params.buildVerbosity}' -ILMerge -Sign -Branch '${branchName}'"
                        echo output
                    }

                    stage('Build install packages')
                    {
                        echo "Building the installers for version $buildVersion"
                        output = powershell ".\\build.ps1 BuildInstallPackages -Configuration '${params.buildConfig}' -Verbosity '${params.buildVerbosity}' -Sign -Branch '${branchName}'"
                        echo output
                    }

                    try
                    {						
                        stage('Tests and Static analysis')
                        {
                            parallel(
                                "Extended code analysis":
                                {
                                    echo "Extending code analysis"
                                    output = powershell ".\\build.ps1 ExtendedCodeAnalysis -Verbosity '${params.buildVerbosity}' -Branch '${branchName}'"
                                    echo output
                                },

                                "Run unit tests":
                                {
                                    if (shouldRunUnitTests)
                                    {
                                        echo "Running the unit tests"
                                        output = powershell ".\\build.ps1 UnitTests -ILMerge -Branch '${branchName}'"
                                        echo output
                                    }
                                },

                                "Run integration tests":
                                {
                                    if (shouldRunIntegrationTests)
                                    {
                                        echo "Running the integration tests"
                                        output = powershell ".\\build.ps1 IntegrationTests -ILMerge -TestEnvironment $params.testEnvironment -Branch '${branchName}'"
                                        echo output
                                    }
                                },
                                
                                "Code coverage report":
                                {
                                    if (shouldRuncodeCoverageReport)
                                    {
                                        echo "Creating a code coverage report"
                                        output = powershell ".\\build.ps1 CodeCoverageReport -TestEnvironment $params.testEnvironment -Branch '${branchName}'"
                                        echo output
                                    }
                                    else
                                    {
                                        echo "Skip creating code coverage report due to configuration parameter. This only runs if you want to run the integration tests as well"
                                    }
                                },
                                failFast: true
                            )
                        }
                    }
                    finally
                    {
                        if (shouldRunUnitTests || shouldRunIntegrationTests)
                        {
                            stage('Test results report')
                            {
                                echo "Generating test report"
                                powershell ".\\build.ps1 TestReports -Branch '${branchName}'"
                            }
                        }

                        if (shouldRunUnitTests || shouldRunIntegrationTests)
                        {
                            parallel(
                                "Retrieve test results":
                                {
                                    def taskCandidates = []
                                    if (shouldRunUnitTests)
                                    {
                                        taskCandidates.add("UnitTestResults")
                                    }

                                    if (shouldRunIntegrationTests)
                                    {
                                        taskCandidates.add("IntegrationTestResults")
                                    }

                                    taskCandidates.eachWithIndex { task, index ->
                                        def testDescription = ""
                                        switch (index)
                                        {
                                            case 0:
                                                testDescription = "unit"
                                                break

                                            case 1:
                                                testDescription = "integration"
                                                break

                                            default:
                                                throw new Exception("The test result type $index is not mapped.")
                                        }

                                        // Let the build script retrieve the unit test result values.
                                        echo "Retrieving the $testDescription-test results"
                                        def testResultOutputString = runCommandWithOutput(".\\build.ps1 ${task} -Verbosity '${params.buildVerbosity}' -Branch '${branchName}'")
                                        echo "Retrieved the $testDescription-test results"

                                        // Search for specific tokens within the response.
                                        echo "Extracting the $testDescription-test result parameters"
                                        def int passed = extractValue("testResultsPassed", testResultOutputString)
                                        def int failed = extractValue("testResultsFailed", testResultOutputString)
                                        def int skipped = extractValue("testResultsSkipped", testResultOutputString)
                                        echo "Extracted the $testDescription-test result parameters"

                                        // Dump the individual test results
                                        echo "$testDescription-test passed: $passed"
                                        echo "$testDescription-test failed: $failed"
                                        echo "$testDescription-test skipped: $skipped"
                                        
                                        // Now add to the final test results
                                        testResultsPassed += passed
                                        testResultsFailed += failed
                                        testResultsSkipped += skipped
                                    }

                                    // Dump the final test results
                                    echo "Total passed: $testResultsPassed"
                                    echo "Total failed: $testResultsFailed"
                                    echo "Total skipped: $testResultsSkipped"
                                },
                                
                                "Create NuGet packages":
                                {
                                    echo "Build number: ${currentBuild.number}"
                                    echo "Building all SDK and RDC packages"
                                    powershell ".\\build.ps1 BuildPackages -Branch '${branchName}' -BuildNumber '${currentBuild.number}'"
                                },
                                failFast: true
                            )
                        }
                    }

                    stage ('Publish everything') 
                    {
                        parallel(
                            "Publish packages to proget":
                            {
                                if (params.publishPackages)
                                {
								    try
									{
										withCredentials([string(credentialsId: 'ProgetNugetApiKey', variable: 'key')]) 
										{
											if (publishSdkAndRdc)  
											{
												echo "Publishing the SDK and RDC package(s)"
												powershell ".\\build.ps1 PublishPackages -Branch '${branchName}'  -ProgetApiKey '$key'" 
											}
											else 
											{
												if(publishSdk)
												{
													echo "Publishing the SDK only"
													powershell ".\\build.ps1 PublishPackages -SkipPublishRdcPackage -Branch '${branchName}'  -ProgetApiKey '$key'" 
												}
												else if(publishRdc)
												{
													echo "Publishing RDC only"
													powershell ".\\build.ps1 PublishPackages -SkipPublishSdkPackage -Branch '${branchName}'  -ProgetApiKey '$key'" 
												}
												else
												{
													echo "publishing packages skipped, as we are on a release branch, and this is not a 'GOLD' build. In order to make this a gold build, kick this off manually"
												}
											}
										}
									}
									catch(err)
									{
										echo err.toString()
										currentBuild.result = 'FAILED' 
										echo "Something went wrong publishing the packages"
									}
                                }
                            },

                            "Publish artifacts":
                            {
								try
								{
									echo "Publishing build artifacts"
									output = powershell ".\\build.ps1 PublishBuildArtifacts -Version '$buildVersion' -Branch '${branchName}'"
									echo output
								}
								catch(err)
								{
									echo err.toString()
									currentBuild.result = 'FAILED' 
									echo "Something went wrong publishing the packages"
								}
                            },
                            failFast: true
                        )
                        currentBuild.result = 'SUCCESS'
                    }
                }
                finally
                {
                    echo "Publishing the build logs"
                    archiveArtifacts artifacts: 'Logs/**/*.*'
                    if (shouldRunUnitTests)
                    {
                        echo "Publishing the unit tests report"
                        archiveArtifacts artifacts: 'TestReports/unit-tests/**/*.*'
                    }

                    if (shouldRunIntegrationTests)
                    {
                        echo "Publishing the integration tests report"
                        archiveArtifacts artifacts: 'TestReports/integration-tests/**/*.*'
                    }

                    if (shouldRuncodeCoverageReport)
                    {
                        echo "Publishing the code coverage report"
                        archiveArtifacts artifacts: 'TestReports/code-coverage/**/*.*'
                    }
                } 
            }
            catch(err)
            {
                echo err.toString()
                currentBuild.result = 'FAILED' 
                if (branchName == 'develop' || isReleaseBranch)
                {
                    sendEmailAboutFailureToTeam()
                }
                else
                {
                    sendEmailAboutFailureToAuthor() 
                }
            }
            finally
            {
                try
                {
                    stage('Reporting and Cleanup')
                    {
                        parallel(
                            // StashNotifier second call, passes currentBuild.result to BitBucket as build status 
                            "BitBucket notification":
                            { 
                                notifyBitbucket()
                            },
							"Slack Notification": 
                            {
                                def script = this
                                def String serverUnderTestName = ""
                                def String version = buildVersion
                                def String branch = env.BRANCH_NAME
                                def String buildType = params.buildType
                                def String slackChannel = params.slackChannel
                                def String email = "slack_svc@relativity.com"
                                def int numberOfFailedTests = testResultsFailed
                                def int numberOfPassedTests = testResultsPassed
                                def int numberOfSkippedTests = testResultsSkipped
                                def String message = env.BUILD_TAG
								echo "*************************************************" +
                                    "\n" +
                                    "\n" + "sendCDSlackNotification Parameters: " +
                                    "\n" +
                                    "\n" + "script: " + script +
                                    "\n" + "serverUnderTestName: " + serverUnderTestName +
                                    "\n" + "version: " + version +
                                    "\n" + "branch: " + branch +
                                    "\n" + "buildType: " + buildType +
                                    "\n" + "slackChannel: " + slackChannel +
                                    "\n" + "email: " + email +
                                    "\n" + "numberOfFailedTests: " + numberOfFailedTests +
                                    "\n" + "numberOfPassedTests: " + numberOfPassedTests +
                                    "\n" + "numberOfSkippedTests: " + numberOfSkippedTests +
                                    "\n" + "message: " + message +
                                    "\n" +
                                    "\n*************************************************"
								sendCDSlackNotification(script, serverUnderTestName, version, branch, buildType, slackChannel, email, ['tests': ['passed': numberOfPassedTests, 'failed': numberOfFailedTests, 'skipped': numberOfSkippedTests]], message, "CD" )

                            }
                        )
                    }
                }
                catch (err)
                {
                    // Just catch everything here, if reporting/cleanup is the only thing that failed, let's not fail out the pipeline.
                    echo err.toString()
                }
            }
        }
    }
}

def sendEmailAboutFailureToAuthor()
{
    def commiterDetails = bat (
        script: 'git --no-pager show -s --format=%ae', 
        returnStdout: true
    )

    def recipients = extractCommiterEmail(commiterDetails)
    sendEmailAboutFailure(recipients)
}

def sendEmailAboutFailureToTeam()
{
   def recipients = 'thegoodthebadandtheugly@relativity.com'
   sendEmailAboutFailure(recipients)
}

def sendEmailAboutFailure(String recipients)
{
    echo "Sending ${branchName} build failure to $recipients"
    def subject = "${env.JOB_NAME} - Build ${env.BUILD_DISPLAY_NAME} - Failed! On branch ${branchName}"
    def body = """${env.JOB_NAME} - Build - Failed:

Check console output at ${env.BUILD_URL} to view the results."""
    sendEmail(body, subject, recipients)
}

def sendEmail(String body, String subject, String recipients)
{
    emailext attachLog: true, attachmentsPattern: 'TestResults/**/*.*', body: body, subject: subject, to: recipients
}

def extractCommiterEmail(details) {
    
    def arr = details.tokenize('\n')
    def email = arr[2].trim()
    return email
}

def extractValue(String value, String output)
{
    if (value == null || value.isEmpty())
    {
        return ""
    }

    def matcher = output =~ "$value=(.*)"
    $result =  matcher[0][0].split("=")[1]
    matcher = null
    return $result
}

def runCommandWithOutput(String command)
{
    def outputString = powershell(returnStdout: true, script: command).trim()
    if (!outputString) 
    {
        error("$command command returned empty output!")
    }

    return outputString
}
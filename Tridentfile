#!groovy
import groovy.json.JsonOutput 
library 'ProjectMayhem@v1'
library 'SlackHelpers@5.2.0-Trident'

properties([
    buildDiscarder(logRotator(artifactDaysToKeepStr: '7', artifactNumToKeepStr: '30', daysToKeepStr: '7', numToKeepStr: '30')),
    parameters([
        choice(defaultValue: 'DEV',choices: ["DEV", "GOLD - RDC AND SDK", "GOLD - RDC ONLY", "GOLD - SDK ONLY"], description: "Choose your build type, only gold can produce production packages.", name: 'buildType'),
        choice(defaultValue: 'Release', choices: ["Release","Debug"], description: 'Build config', name: 'buildConfig'),
        choice(defaultValue: 'normal', choices: ["quiet", "minimal", "normal", "detailed", "diagnostic"], description: 'Build verbosity', name: 'buildVerbosity'),
        string(defaultValue: 'current', description: 'Relativity branch to test against, leave current for version installed on hopper image', name: 'relativityBranch'),
        booleanParam(defaultValue: true, description: "Enable or disable running unit tests", name: 'runUnitTests'),
        booleanParam(defaultValue: true, description: "Enable or disable running integration tests", name: 'runIntegrationTests'),
        booleanParam(defaultValue: true, description: "Enable or disable creating a code coverage report", name: 'createCodeCoverageReport'),
        choice(defaultValue: 'Hopper', choices: ["Hopper"], description: 'The test environment used for integration tests and code coverage', name: 'testEnvironment'),
        booleanParam(defaultValue: true, description: """Enable or disable publishing NuGet packages, default true, but can be blocked by type of build and branch type.
        This is only for debug purposes.""", name: 'publishPackages')
    ])
])

def buildVersion = ""
def packageVersion = ""
String commitHash = null
def int testResultsPassed = 0
def int testResultsFailed = 0
def int testResultsSkipped = 0

// The following code is needed because we build a pull request according to Jenkins, 'so' the env.Branch does not return a valid branch name, but only 'PR-1234', and we need the branch name for our logic.
def branchName = env.BRANCH_NAME
if(branchName.startsWith('PR-'))
{
    branchName = env.CHANGE_BRANCH
}
def isReleaseBranch = branchName.startsWith('release-')
// TODO - remove REL- after tests
def isMasterBranch = branchName.startsWith('master') || branchName.startsWith('REL-793725')
def isReleaseOrMasterBranch = isReleaseBranch || isMasterBranch
def isGoldBuild = (params.buildType != 'DEV')
def publishToRelease = (isGoldBuild && isReleaseOrMasterBranch)
def publishRdc =(!isReleaseOrMasterBranch || (isReleaseOrMasterBranch && params.buildType == 'GOLD - RDC AND SDK')|| (isReleaseOrMasterBranch && params.buildType == 'GOLD - RDC ONLY'))
def publishSdk =(!isReleaseOrMasterBranch || (isReleaseOrMasterBranch && params.buildType == 'GOLD - RDC AND SDK')|| (isReleaseOrMasterBranch && params.buildType == 'GOLD - SDK ONLY'))
def publishSdkAndRdc = (publishSdk && publishRdc)
build = params.build

// On release branches tests should be executed against newest Relativity version from specified folder in \\bld-pkgs\Packages\Relativity\
// Example: relativityBranch = 'release-11.3-mayapple' for branchName = 'release-1.11-mayapple'
// Example: relativityBranch = 'current' for relativity version installed on hopper - specific version installation is not performed
if(isReleaseOrMasterBranch && (relativityBranch == null || relativityBranch.isEmpty()))
{
	currentBuild.result = 'FAILED' 
	throw new Exception("Build failed because relativity installer source folder 'relativityBranch' is not defined in the script")
}

def config = [
	sutTemplate: "aio-zarzaparrilla-0",
	hopperApiUrl: "https://api.hopper.relativity.com/",
	hopperApiUsername: "homeimprovement@relativity.com"
]

def vmInfo = null
	
// The code coverage report runs the integration tests + unit tests.
def shouldRuncodeCoverageReport = params.createCodeCoverageReport && params.runIntegrationTests && params.runUnitTests

// Disable running unit tests if we already run the code coverage report (that invokes the unit tests as well)
def shouldRunUnitTests = params.runUnitTests && !shouldRuncodeCoverageReport

// Disable running integration tests if we already run the code coverage report (that invokes the integration tests as well)
def shouldRunIntegrationTests = params.runIntegrationTests && !shouldRuncodeCoverageReport
	
def tools					

	
timestamps
{
    timeout(time: 3, unit: 'HOURS')
    {
        node('role-build-agent||buildAgent')
        {
            try
            {
				stage ('Clean') 
				{
					deleteDir()
				}
				
                stage('Checkout')
                {
                    commitHash = checkout([
                        $class: 'GitSCM',
                        branches: scm.branches,
                        doGenerateSubmoduleConfigurations: scm.doGenerateSubmoduleConfigurations,
                        extensions: [[$class: 'CloneOption', noTags: false, shallow: false, reference: '']] + [[$class: 'CleanCheckout']],
                        userRemoteConfigs: scm.userRemoteConfigs,
                     ]).GIT_COMMIT
					echo "GIT_COMMIT is ${commitHash}"
                    notifyBitbucket()
					tools = load 'Trident/Tools/Tools.groovy'
					Slack = load 'Trident/Tools/Slack.groovy'
                }
				
                try
                {					
                    stage('Retrieve version')
                    {
                        echo "Is release branch = $isReleaseOrMasterBranch"
                        echo "Run integration tests = ${shouldRunIntegrationTests}"
                        echo "Is gold build = $isGoldBuild"
                        echo "Publishing to release? $publishToRelease"
                        echo "Retrieving the semantic versions"
                        echo "Using new build strategy"
                        def outputString = tools.runCommandWithOutput(".\\build.ps1 BuildVersion -Branch '${branchName}'")
                        def outputStringParsed = tools.extractValue("buildVersion", outputString)
                        currentBuild.displayName = "$outputStringParsed"
                        buildVersion = outputStringParsed
                    }
					
					stage('Tag version in GIT')
                    {
                        echo "Publishing to release? $publishToRelease"
						if(publishToRelease)
						{
							echo "Tagging git"
							withCredentials([usernamePassword(credentialsId: 'JenkinsKcuraBBSVC', passwordVariable: 'password', usernameVariable: 'username')]) {
								tools.tagGitCommit(commitHash, buildVersion, username, password)
							}
							echo "Tagging git success."
						}
						else
						{
							echo "Not a gold build that is pushed to release, so no tagging GIT"
						}
                    }

					stage('Get hopper instance') 
					{
						echo "Hopper variables will be printed"
						def output = JsonOutput.toJson(config)
						echo JsonOutput.prettyPrint(output)
						echo "End of hopper variables"
						vmInfo = tools.createHopperInstance(config.sutTemplate, params.relativityBranch)
					}	

					stage('Install DataTransfer.Legacy app')
					{
						echo "Installing DataTransfer.Legacy app"
						output = powershell ".\\build.ps1 InstallDataTransferLegacyRap -TestTarget '${(new URI(vmInfo.Url)).getHost()}'"
						echo output
					}

					stage('Replace variables in build')
					{
					    echo "replacing test variables in build"
					    echo "vmInfo url ${vmInfo.Url}"
					    echo "vmInfo id ${vmInfo.Id}"
                        output = powershell ".\\build.ps1 ReplaceTestVariables -TestTarget '${(new URI(vmInfo.Url)).getHost()}'"
                        echo output
					}
					
                    stage('Build binaries') 
                    {
                        echo "Building the binaries for version $buildVersion"
                        output = powershell ".\\build.ps1 UpdateAssemblyInfo,Build,BuildUIAutomation -Configuration '${params.buildConfig}' -Verbosity '${params.buildVerbosity}' -ILMerge -Sign -Branch '${branchName}'"
                        echo output
                    }
                    
					stage('Build install packages and check sdk dependencies')
					{
						parallel(
							"Check sdk dependencies":
							{
								echo "checking dependencies of the .sdk .nuspec file"
								powershell ".\\build.ps1 CheckSdkDependencies"
							},

							"Check access to destination path":
							{
								powershell ".\\build.ps1 CheckFolderAccess"
							},

							"Build install packages":
							{
								echo "Building the installers for version $buildVersion"
								output = powershell ".\\build.ps1 BuildInstallPackages -Configuration '${params.buildConfig}' -Verbosity '${params.buildVerbosity}' -Sign -Branch '${branchName}'"
								echo output
							},
							failFast: true
						)
					}

                    try
                    {
                        stage("Run unit tests")
                        {
                            if (shouldRunUnitTests)
                            {
                                echo "Running the unit tests"
                                output = powershell ".\\build.ps1 UnitTests -ILMerge -Branch '${branchName}'"
                                echo output
                            }
                            else
                            {
                                echo "Skip running unit tests due to configuration parameters."
                            }
                        }
                        
                        stage("Run integration tests")
                        {
                            if (shouldRunIntegrationTests)
                            {
                                echo "Running the integration tests"
                                output = powershell ".\\build.ps1 IntegrationTests -ILMerge -TestEnvironment '${params.testEnvironment}' -Branch '${branchName}'"
                                echo output
                            }
                            else
                            {
                                echo "Skip running integration tests due to configuration parameters."
                            }
                        }
                        
                        stage("Code coverage report")
                        {
                            if (shouldRuncodeCoverageReport)
                            {
                                echo "Creating a code coverage report"
                                output = powershell ".\\build.ps1 CodeCoverageReport -TestEnvironment '${params.testEnvironment}' -Branch '${branchName}'"
                                echo output
                            }
                            else
                            {
                                echo "Skip creating code coverage report due to configuration parameter. This only runs if you want to run the integration tests as well"
                            }
                        }
                    }
                    finally
                    { 
                        if (shouldRunUnitTests || shouldRunIntegrationTests || shouldRuncodeCoverageReport)
                        {
                            stage('Test results report')
                            {
                                echo "Generating test report"
                                powershell ".\\build.ps1 TestReports -Branch '${branchName}'"
                            }
                        }

                        if (shouldRunUnitTests || shouldRunIntegrationTests || shouldRuncodeCoverageReport)
                        {
						    stage('Retrieve test results and create NuGet packages')
                            {
								parallel(
									"Retrieve test results":
									{
										def taskCandidates = []
										if (shouldRunUnitTests)
										{
											taskCandidates.add("UnitTestResults")
										}

										if (shouldRunIntegrationTests)
										{
											taskCandidates.add("IntegrationTestResults")
										}
										
										if (shouldRuncodeCoverageReport)
										{
											taskCandidates.add("UnitTestResults")
											taskCandidates.add("IntegrationTestResults")
										}

										taskCandidates.eachWithIndex { task, index ->
											def testDescription = ""
											switch (index)
											{
												case 0:
													testDescription = "unit"
													break

												case 1:
													testDescription = "integration"
													break

												default:
													throw new Exception("The test result type $index is not mapped.")
											}

											// Let the build script retrieve the unit test result values.
											echo "Retrieving the $testDescription-test results"
											def testResultOutputString = tools.runCommandWithOutput(".\\build.ps1 ${task} -Verbosity '${params.buildVerbosity}' -Branch '${branchName}'")
											echo "Retrieved the $testDescription-test results"

											// Search for specific tokens within the response.
											echo "Extracting the $testDescription-test result parameters"
											def int passed = tools.extractValue("testResultsPassed", testResultOutputString)
											def int failed = tools.extractValue("testResultsFailed", testResultOutputString)
											def int skipped = tools.extractValue("testResultsSkipped", testResultOutputString)
											echo "Extracted the $testDescription-test result parameters"

											// Dump the individual test results
											echo "$testDescription-test passed: $passed"
											echo "$testDescription-test failed: $failed"
											echo "$testDescription-test skipped: $skipped"
											
                                            // Now add to the final test results
                                            testResultsPassed += passed
                                            testResultsFailed += failed
                                            testResultsSkipped += skipped
											
                                            if(failed > 0)
                                            {
                                                echo "$testDescription-test failed is bigger than zero"
                                                currentBuild.result = 'FAILED' 
                                                throw new Exception("Tests failed.")
                                            }
										}

                                        // Dump the final test results
                                        echo "Total passed: $testResultsPassed"
                                        echo "Total failed: $testResultsFailed"
                                        echo "Total skipped: $testResultsSkipped"
									},
									
									"Create NuGet packages":
									{
										echo "Build number: ${currentBuild.number}"
										echo "Building all SDK and RDC packages"
										powershell ".\\build.ps1 BuildPackages -Branch '${branchName}' -BuildNumber '${currentBuild.number}'"
									},
									failFast: true
								)
							}
                        }
                    }

                    stage ('Publish everything') 
                    {
                        parallel(
                            "Publish packages to proget":
                            {
                                if (params.publishPackages)
                                {
								    try
									{
										withCredentials([string(credentialsId: 'ProgetNugetApiKey', variable: 'key')]) 
										{
											if (publishSdkAndRdc)  
											{
												echo "Publishing the SDK and RDC package(s)"
												powershell ".\\build.ps1 PublishPackages -Branch '${branchName}'  -ProgetApiKey '$key'" 
											}
											else 
											{
												if(publishSdk)
												{
													echo "Publishing the SDK only"
													powershell ".\\build.ps1 PublishPackages -SkipPublishRdcPackage -Branch '${branchName}'  -ProgetApiKey '$key'" 
												}
												else if(publishRdc)
												{
													echo "Publishing RDC only"
													powershell ".\\build.ps1 PublishPackages -SkipPublishSdkPackage -Branch '${branchName}'  -ProgetApiKey '$key'" 
												}
												else
												{
													echo "publishing packages skipped, as we are on a release branch, and this is not a 'GOLD' build. In order to make this a gold build, kick this off manually"
												}
											}
										}
									}
									catch(err)
									{
										echo err.toString()
										currentBuild.result = 'FAILED' 
										echo "Something went wrong publishing the packages"
									}
                                }
                            },

                            "Publish artifacts":
                            {
								try
								{
									echo "Publishing build artifacts"
									output = powershell ".\\build.ps1 PublishBuildArtifacts -Version '$buildVersion' -Branch '${branchName}' -PublishToRelease \$${publishToRelease}"
									echo output
								}
								catch(err)
								{
									echo err.toString()
									currentBuild.result = 'FAILED' 
									echo "Something went wrong publishing the packages"
								}
                            },
                            failFast: true
                        )
                        currentBuild.result = 'SUCCESS'
                    }
					stage('Create einstein page')
					{	
						if(publishSdkAndRdc && publishToRelease)
						{
							def secrets = [ 
							[ secretType: 'Secret', name: 'Einstein-token', envVariable: 'EinsteinToken' ]
							]
							withAzureKeyvault(azureKeyVaultSecrets: secrets, keyVaultURLOverride: 'https://KV-DATATRANSFER-GBU.vault.azure.net') { 
								powershell ".\\build.ps1 PostReleasePageOnEinstein -EinsteinSecret '${EinsteinToken}' -Branch '${branchName}'"
							}
						}
						else
						{
						    echo "We can't create a release page as this needs a gold build of SDK and RDC to be created on release branch."
						}
					}
                }
                finally
                {
					echo "Remove redundant test output files that should not be added to Trident logs"
					powershell ".\\build.ps1 RemoveRedundantTestOutputFiles -Branch '${branchName}'"				
					
                    echo "Publishing the build logs"
                    archiveArtifacts artifacts: 'Logs/**/*.*'
                    if (shouldRunUnitTests)
                    {
                        echo "Publishing the unit tests report"
                        archiveArtifacts artifacts: 'TestReports/unit-tests/**/*.*'
                    }
                    
                    if (shouldRunIntegrationTests)
                    {
                        echo "Publishing the integration tests report"
                        archiveArtifacts artifacts: 'TestReports/integration-tests/**/*.*'
                    }

                    if (shouldRuncodeCoverageReport)
                    {
						echo "Publishing the unit tests report"
                        archiveArtifacts artifacts: 'TestReports/unit-tests/**/*.*'
						
						echo "Publishing the integration tests report"
                        archiveArtifacts artifacts: 'TestReports/integration-tests/**/*.*'
						
                        echo "Publishing the code coverage report"
                        archiveArtifacts artifacts: 'TestReports/code-coverage/**/*.*'
                    }
                } 
            }
            catch(err)
            {
                echo err.toString()
                currentBuild.result = 'FAILED' 
                if (branchName == 'develop' || isReleaseOrMasterBranch)
                {
                    tools.sendEmailAboutFailureToTeam(branchName)
                }
                else
                {
                    tools.sendEmailAboutFailureToAuthor(branchName) 
                }
                tools.transferHopper(vmInfo)
            }
            finally
            {
                stage('Send slack and bitbucket notification')
                {
                    notifyBitbucket()
                    Slack.SendSlackNotification("Relativity from image '${config.sutTemplate}'", buildVersion, env.BRANCH_NAME, params.buildType, "build", testResultsFailed, testResultsPassed, testResultsSkipped, env.BUILD_TAG)
                }
            }
        }
    }
}